--Kyle 'Avoca' Abent



if Server then
------------------------------------------------------------
local ontg = ARC.OnTag 
    function ARC:OnTag(tagName)
     ontg(self, tagName) 
         if tagName == "deploy_start" then
               if (   GetIsInSiege(self) and not GetTimer():GetSiegeOpenBoolean() ) then
                self:Kill() 
               end
        end
     end
------------------------------------------------------------
    function ARC:OnOrderComplete(currentOrder)     
       if (GetIsInSiege(self) and not GetTimer():GetSiegeOpenBoolean() ) then
            self:Kill() 
       end
    end
------------------------------------------------------------
    function MAC:OnOrderComplete(currentOrder)
       if (   GetIsInSiege(self) and not GetTimer():GetSiegeOpenBoolean() ) then
         self:Kill() 
        end 
        ///hmm??
                    if self.autoReturning then
                self.leashedPosition = nil
               self.autoReturning = false
            end
    end
------------------------------------------------------------
    local constorig = ConstructMixin.OnConstructionComplete
    function ConstructMixin:OnConstructionComplete(builder)
      constorig(self, builder)
         if (  GetIsInSiege(self) and not GetTimer():GetSiegeOpenBoolean() ) then
        self:Kill() 
         end 
    end    
------------------------------------------------------------
    function TeleportMixin:OnTeleportEnd(shift)
    end
------------------------------------------------------------
    local origtp = TeleportMixin.OnTeleportEnd
    function TeleportMixin:OnTeleportEnd(shift)
    origtp (self, shift)
       if (  GetIsInSiege(self)  and not GetTimer():GetSiegeOpenBoolean() ) then
        self:Kill()
       end 
    end
 ------------------------------------------------------------      
    local cystorig = Cyst.OnInitialized
    function Cyst:OnInitialized()
      cystorig(self)
      if not GetTimer():GetFrontOpenBoolean() then
          local frontdoor = nil
          frontdoor = GetNearest(self:GetOrigin(), "FrontDoor", 0, function(ent) return self:GetDistance(ent) <= 13   end)
          if frontdoor  then 
            self:Kill()
            return 
          end
       end
    end   
------------------------------------------------------------
    local contorig = Contamination.OnInitialized
    function Contamination:OnInitialized()
      contorig(self)
              if (  GetIsInSiege(self)  and not GetTimer():GetSiegeOpenBoolean() ) then
                   self:Kill()
             end 
    end    
------------------------------------------------------------
    local drifterorig = Drifter.OnInitialized
    function Drifter:OnInitialized()
      drifterorig(self)
          if (  GetIsInSiege(self)  and not GetTimer():GetSiegeOpenBoolean() ) then
            self:Kill()
         end 
    end    
------------------------------------------------------------
    local eggorig = Egg.OnInitialized
    function Egg:OnInitialized()
      eggorig(self)
              if (  GetIsInSiege(self)  and not GetTimer():GetSiegeOpenBoolean() ) then
            self:Kill()
             end 
    end    
------------------------------------------------------------
    local tunnelorig = TunnelEntrance.OnInitialized
    function TunnelEntrance:OnInitialized()
      tunnelorig(self)
              if (  GetIsInSiege(self)  and not GetTimer():GetSiegeOpenBoolean() ) then
            self:Kill()
             end 
    end   
------------------------------------------------------------ 
end // Server   

function PathingMixin:CheckTarget(endPoint)

    // if we don't have a cursor, or the targetPoint differs, create a new path
    if self.cursor == nil or (self.targetPoint - endPoint):GetLengthXZ() > 0.1 then
    
        // our current cursor is invalid or pointing to another endpoint, so build a new one
        self.points = GeneratePath(self:GetOrigin(), endPoint, false, 0.5, 2, self:GetIsFlying())
        if self.points == nil then
        
            // Can't reach the endPoint.
            return false
            
        end
        self.targetPoint = endPoint
        // the list of points does not include our current origin. Simplify the remaining code
        // by adding our origin to the list of points
        Pathing.InsertPoint( self.points, 1, self:GetOrigin() )
        
        self.cursor = PathCursor():Init(self.points)
        
    end    
    local trace = Shared.TraceRay(self:GetOrigin(),  endPoint, CollisionRep.Move, PhysicsMask.Movement, EntityFilterAllButIsa("SiegeDoor") )                                                                                                                                                                                                                                                                            
      if trace.entity ~= nil and trace.entity:GetIsLocked() then 
        return false
     end
  
  return true
    
end
---------------------------
//Shell, Spur, Veil, and Drifter limits. Why? because without these, alien commanders like to exploit and spawn billions of these.
--------------------------
function GetCheckShellLimit(techId, origin, normal, commander)
    local num = 0
    for index, shell in ientitylist(Shared.GetEntitiesWithClassname("Shell")) do
      num = num + 1
    end
    return num < 6
end
------------------------------------------------------------
function GetCheckVeilLimit(techId, origin, normal, commander)
    local num = 0
        for index, veil in ientitylist(Shared.GetEntitiesWithClassname("Veil")) do
                num = num + 1 
    end
    return num < 6
end
------------------------------------------------------------
function GetCheckSpurLimit(techId, origin, normal, commander)
    local num = 0
        for index, spur in ientitylist(Shared.GetEntitiesWithClassname("Spur")) do
            if not spur:isa("StructureBeacon") then 
                num = num + 1
            end
    end
    return num < 6
end
------------------------------------------------------------
function GetCheckArmsLimit(techId, origin, normal, commander)
    local num = 0
        for index, arms in ientitylist(Shared.GetEntitiesWithClassname("ArmsLab")) do
            num = num + 1
    end
    return num < 6
end
------------------------------------------------------------
function GetCheckDrifterLimit(techId, origin, normal, commander)
    local num = 0
    for index, spur in ientitylist(Shared.GetEntitiesWithClassname("Drifter")) do
      num = num + 1  
    end
    for index, derp in ientitylist(Shared.GetEntitiesWithClassname("DrifterEgg")) do
     num = num + 1
    end
    return num < 10
end
------------------------------------------------------------
function GetCheckDropMACLimit(techId, origin, normal, commander)
    local num = 0 
        for index, mac in ientitylist(Shared.GetEntitiesWithClassname("MAC")) do
             if not mac:isa("MACCredit") then
                num = num + 1
             end
    end
    return num < 12 
end
------------------------------------------------------------
function GetCheckDrifterLimit(techId, origin, normal, commander)
    local num = 0
        for index, shell in ientitylist(Shared.GetEntitiesWithClassname("Drifter")) do
        num = num + 1
    end
    return num < 12
end
------------------------------------------------------------
function GetCheckExoSuitLimit(techId, origin, normal, commander)
    local num = 0
    for index, exosuit in ientitylist(Shared.GetEntitiesWithClassname("Exosuit")) do
       num = num + 1  
    end
    return num < 8
end
------------------------------------------------------------
function GetCheckJetpackLimit(techId, origin, normal, commander)
    local num = 0
     for index, jp in ientitylist(Shared.GetEntitiesWithClassname("Jetpack")) do
     num = num + 1  
    end
    return num < 8
    
end
------------------------------------------------------------
function GetCheckCommandStationLimit(techId, origin, normal, commander)
    local num = 0
       for _, cc in ipairs(GetEntitiesWithinRange("CommandStation", origin, 9999)) do
        
                num = num + 1      
    end
    return num < 3
end
------------------------------------------------------------
SetCachedTechData(kTechId.CommandStation, kTechDataAttachOptional, true)
SetCachedTechData(kTechId.CommandStation, kTechDataBuildRequiresMethod, GetCheckCommandStationLimit)
SetCachedTechData(kTechId.Drifter, kTechDataBuildMethodFailedMessage, "Limit reached for Commander ents of this type")
SetCachedTechData(kTechId.Spur, kTechDataBuildMethodFailedMessage, "Limit Reached")
SetCachedTechData(kTechId.Veil, kTechDataBuildMethodFailedMessage, "Limit Reached")
SetCachedTechData(kTechId.ArmsLab, kTechDataBuildMethodFailedMessage, "Limit Reached")
SetCachedTechData(kTechId.ArmsLab, kTechDataBuildRequiresMethod, GetCheckArmsLimit)
SetCachedTechData(kTechId.Shell, kTechDataBuildMethodFailedMessage, "Limit Reached")
SetCachedTechData(kTechId.Spur, kTechDataBuildRequiresMethod, GetCheckSpurLimit)
SetCachedTechData(kTechId.Veil, kTechDataBuildRequiresMethod, GetCheckVeilLimit)
SetCachedTechData(kTechId.Shell, kTechDataBuildRequiresMethod, GetCheckShellLimit)
SetCachedTechData(kTechId.Drifter, kTechDataBuildRequiresMethod, GetCheckDrifterLimit)
SetCachedTechData(kTechId.Drifter, kTechDataBuildMethodFailedMessage, "Limit Reached")
SetCachedTechData(kTechId.DrifterEgg, kTechDataBuildRequiresMethod, GetCheckDrifterLimit)
SetCachedTechData(kTechId.DrifterEgg, kTechDataBuildMethodFailedMessage, "Limit Reached")
SetCachedTechData(kTechId.DropExosuit, kTechDataBuildRequiresMethod, GetCheckExoSuitLimit)
SetCachedTechData(kTechId.DropExosuit, kTechDataBuildMethodFailedMessage, "Limit Reached")
SetCachedTechData(kTechId.DropJetpack, kTechDataBuildRequiresMethod, GetCheckJetpackLimit)
SetCachedTechData(kTechId.DropJetpack, kTechDataBuildMethodFailedMessage, "Limit Reached")
---------------------------------------------------------------