--Kyle 'Avoca' Abent

local ontg = ARC.OnTag 

function ARC:OnTag(tagName)
if Server then
 ontg(self, tagName)
 
     if tagName == "deploy_start" then
           if (   GetIsInSiege(self)    and not GetTimer():GetIsSiegeOpen() ) then
          self:Kill() 
           end
    end
    end
end

function ARC:OnOrderComplete(currentOrder)

 if Server then    
            
           if (   GetIsInSiege(self)    and not GetTimer():GetIsSiegeOpen() ) then
          self:Kill() 
           end


      end
    
end

function MAC:OnOrderComplete(currentOrder)

if Server then  
       if (   GetIsInSiege(self)   and not GetTimer():GetIsSiegeOpen() ) then
        self:Kill() 
         end 
end

end


local constorig = ConstructMixin.OnConstructionComplete
function ConstructMixin:OnConstructionComplete(builder)
  constorig(self, builder)
  if Server then 

         if (  GetIsInSiege(self)  and not GetTimer():GetIsSiegeOpen() ) then
        self:Kill() 
         end 

 end --CommPoint(self, 1) end
end    

/*
local clogorig = Clog.OnInitialized

function Clog:OnInitialized()
  clogorig(self)
  if Server then ExploitCheck(self) end
end    
*/

if Server then
function TeleportMixin:OnTeleportEnd(shift)//polymorphism overrode by 
end
local origtp = TeleportMixin.OnTeleportEnd
    function TeleportMixin:OnTeleportEnd(shift)
    origtp (self, shift)
       if (  GetIsInSiege(self)  and not GetTimer():GetIsSiegeOpen() ) then
        self:Kill()
         end 
    end
 end   
 
 /*
local cystorig = Cyst.OnInitialized

function Cyst:OnInitialized()
  cystorig(self)
  if Server  and not GetTimer():GetFrontOpenBoolean() then
  local frontdoor = nil
            frontdoor = GetNearest(self:GetOrigin(), "FrontDoor", 0, function(ent) return self:GetDistance(ent) <= 13   end) --was 12 now 13 because csiege bunker room :/
                 if frontdoor  then self:Kill( )return end
            //frontdoor = frontdoor or GetIsRoomPowerUp(who) -- if it doesnt cause problems with maps. Power shouldn't be up alien side.
    end
end   
*/

local contorig = Contamination.OnInitialized
function Contamination:OnInitialized()
    contorig(self)
  if Server then 
          if (  GetIsInSiege(self)  and not GetTimer():GetIsSiegeOpen() ) then
               self:Kill()
         end 
   end
 
end    
 

local drifterorig = Drifter.OnInitialized
function Drifter:OnInitialized()
  drifterorig(self)
  if Server then
          if (  GetIsInSiege(self)  and not GetTimer():GetIsSiegeOpen() ) then
        self:Kill()
         end 

     end
end    

local eggorig = Egg.OnInitialized

function Egg:OnInitialized()
  eggorig(self)
  if Server then 
          if (  GetIsInSiege(self)  and not GetTimer():GetIsSiegeOpen() ) then
        self:Kill()
         end 
  end
end    

local tunnelorig = TunnelEntrance.OnInitialized
function TunnelEntrance:OnInitialized()
  tunnelorig(self)
  if Server then
          if (  GetIsInSiege(self)  and not GetTimer():GetIsSiegeOpen() ) then
        self:Kill()
         end 
   end
end    

/*
local contorig = Contamination.OnInitialized


local function OnRolloutTimeout(self)
 if Server then ExploitCheck(self) end
    return false
end

local rollorig =  RolloutMixin.Rollout
function RolloutMixin:Rollout(factory, factoryRolloutLength)
  rollorig(self, factory, factoryRolloutLength)
   self:AddTimedCallback(OnRolloutTimeout, 12)
end    
*/

--lazy

function PathingMixin:CheckTarget(endPoint)

    // if we don't have a cursor, or the targetPoint differs, create a new path
    if self.cursor == nil or (self.targetPoint - endPoint):GetLengthXZ() > 0.1 then
    
        // our current cursor is invalid or pointing to another endpoint, so build a new one
        self.points = GeneratePath(self:GetOrigin(), endPoint, false, 0.5, 2, self:GetIsFlying())
        if self.points == nil then
        
            // Can't reach the endPoint.
            return false
            
        end
        self.targetPoint = endPoint
        // the list of points does not include our current origin. Simplify the remaining code
        // by adding our origin to the list of points
        Pathing.InsertPoint( self.points, 1, self:GetOrigin() )
        
        self.cursor = PathCursor():Init(self.points)
        
    end    
    local trace = Shared.TraceRay(self:GetOrigin(),  endPoint, CollisionRep.Move, PhysicsMask.Movement, EntityFilterAllButIsa("SiegeDoor") )                                                                                                                                                                                                                                                                            
      if trace.entity ~= nil and trace.entity:GetIsLocked() then 
        return false
     end
  
  return true
    
end





---------------------------
//Shell, Spur, Veil, and Drifter limits. Why? because without these, alien commanders like to exploit and spawn billions of these.
--------------------------


function GetCheckShellLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, shell in ientitylist(Shared.GetEntitiesWithClassname("Shell")) do
        
           -- if not spur:isa("StructureBeacon") then 
                num = num + 1
          --  end
            
    end
    
    return num < 4
    
end
function GetCheckVeilLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, veil in ientitylist(Shared.GetEntitiesWithClassname("Veil")) do
        
           -- if not spur:isa("StructureBeacon") then 
                num = num + 1
          --  end
            
    end
    
    return num < 4
    
end
function GetCheckSpurLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, spur in ientitylist(Shared.GetEntitiesWithClassname("Spur")) do
        
            if not spur:isa("StructureBeacon") then 
                num = num + 1
            end
            
    end
    
    return num < 4
    
end
function GetCheckDrifterLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, spur in ientitylist(Shared.GetEntitiesWithClassname("Drifter")) do
        
                num = num + 1
            
    end
    
            for index, derp in ientitylist(Shared.GetEntitiesWithClassname("DrifterEgg")) do
        
                num = num + 1
            
    end
    
    return num < 10
    
end

function GetCheckDropMACLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, mac in ientitylist(Shared.GetEntitiesWithClassname("MAC")) do
             if not mac:isa("MACCredit") then
                num = num + 1
             end
    end
    
    
    return num < 12
    
end


function GetCheckDrifterLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, shell in ientitylist(Shared.GetEntitiesWithClassname("Drifter")) do
        
           -- if not spur:isa("StructureBeacon") then 
                num = num + 1
          --  end
            
    end
    
    return num < 12
    
end
function GetCheckExoSuitLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, exosuit in ientitylist(Shared.GetEntitiesWithClassname("Exosuit")) do
        
           -- if not spur:isa("StructureBeacon") then 
                num = num + 1
          --  end
            
    end
    
    return num < 8
    
end


function GetCheckJetpackLimit(techId, origin, normal, commander)
    local num = 0

        
        for index, jp in ientitylist(Shared.GetEntitiesWithClassname("Jetpack")) do
        
           -- if not spur:isa("StructureBeacon") then 
                num = num + 1
          --  end
            
    end
    
    return num < 8
    
end
SetCachedTechData(kTechId.Drifter, kTechDataBuildMethodFailedMessage, "Limit reached for Commander ents of this type")

SetCachedTechData(kTechId.Spur, kTechDataBuildMethodFailedMessage, "Limit Reached", true)
SetCachedTechData(kTechId.Veil, kTechDataBuildMethodFailedMessage, "Limit Reached", true)
SetCachedTechData(kTechId.Shell, kTechDataBuildMethodFailedMessage, "Limit Reached", true)

SetCachedTechData(kTechId.Spur, kTechDataBuildRequiresMethod, GetCheckSpurLimit, true)
SetCachedTechData(kTechId.Veil, kTechDataBuildRequiresMethod, GetCheckVeilLimit, true)
SetCachedTechData(kTechId.Shell, kTechDataBuildRequiresMethod, GetCheckShellLimit, true)

SetCachedTechData(kTechId.Drifter, kTechDataBuildRequiresMethod, GetCheckDrifterLimit, true)
SetCachedTechData(kTechId.Drifter, kTechDataBuildMethodFailedMessage, "Limit Reached", true)

SetCachedTechData(kTechId.DrifterEgg, kTechDataBuildRequiresMethod, GetCheckDrifterLimit, true)
SetCachedTechData(kTechId.DrifterEgg, kTechDataBuildMethodFailedMessage, "Limit Reached", true)

SetCachedTechData(kTechId.DropExosuit, kTechDataBuildRequiresMethod, GetCheckExoSuitLimit, true)
SetCachedTechData(kTechId.DropExosuit, kTechDataBuildMethodFailedMessage, "Limit Reached", true)

SetCachedTechData(kTechId.DropJetpack, kTechDataBuildRequiresMethod, GetCheckJetpackLimit, true)
SetCachedTechData(kTechId.DropJetpack, kTechDataBuildMethodFailedMessage, "Limit Reached", true)


SetCachedTechData(kTechId.SentryBattery, kTechDataDisplayName, "BackupBattery")
SetCachedTechData(kTechId.SentryBattery, kTechDataTooltipInfo, "Backup Power!!!")
SetCachedTechData(kTechId.SentryBattery, kTechDataHint, "Backup Power!!!!")



---------------------------------------------------------------